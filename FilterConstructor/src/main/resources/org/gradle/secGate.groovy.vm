##
## This is the velocity gateway template file 
## for the production of gateway filters for Zuul.
## It's mostly testing right now.
##
## Author Luke Grey | productOps, Inc.
## 
/**
 * Author: Luke Grey | productOps, Inc.
 *
 * if nothing in the chain has caused it to fail, and the request has permissions,
 * and one of those permissions are this filters endpoint,  and there are still calls left in the quota
 * then this request should be processed by this filter
 * however if this call doesnt have permission to use this, stop filtering
 * and if there is nothing left in the quota, stop filtering too
 * 
 */
package filters.pre;
import com.netflix.zuul.ZuulFilter
import com.netflix.zuul.ZuulFilterResult
import com.netflix.zuul.context.RequestContext
import com.netflix.zuul.context.Debug
import java.util.Map.Entry

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

class ${name}SecGateV${version} extends ZuulFilter {

	private static final Logger log = LogManager.getLogger(${name}SecGateV${version}.class)
	private static int quota = $quota;
	private static long hostNum = 1;
	private static int traffic = 0;
	private static long lastTimeReset;
	
    @Override
    int filterOrder() {
        return $order
    }

    @Override
    String filterType() {
        return "pre"
    }

    @Override
    boolean shouldFilter() {
#if(!$disabled)
		RequestContext ctx = RequestContext.getCurrentContext();
		if(ctx.getContinueFiltering()){
			if(!ctx.getRequestPermissions().isEmpty()){
				if(ctx.getURIVersionPath()=="$endpoint/v$version")	
					if(trafficPassage()){
						log.info("Quota at " + quota)
						if(quota>0){
							if(ctx.getRequestPermissions().contains("$endpoint/v$version")){
								log.info("Request endpoint $endpoint/v$version recognized")
								return true
							}else{
								ctx.stopFiltering();
								log.error("No permissions for this endpoint")
								ctx.setErrorCondition("lack of permission on this endpoint");
							}
						}else if(quota<1){
							ctx.stopFiltering();
							log.error("Empty quota.")
							ctx.setErrorCondition("being out of passes");
						}
					}else{
						ctx.stopFiltering();
						log.error("Traffic overflow.")
						ctx.setErrorCondition("too much traffic. Slow down, cowboy");
					}
				}
			}
#else
		    log.info("Filter ${name}SecGate disabled.")
#end
	        return false;
		}
	}

    @Override
    Object run() {
        RequestContext ctx = RequestContext.getCurrentContext();
		
        // sets origin
		ArrayList<String> hostList = Array.asList($hosts);
		String host = hostList.get(hostnNum%hostList.size()+1)
		
		ctx.setRouteHost(new URL(host));
		log.info("Set host to "+host);
		
        // sets custom uri to send to the server
        ctx.setRequestURI("$api"+ctx.getNonURIPath());
		log.info("At $api"+ctx.getNonURIPath());
		
		//drop the quota
		quota--;
		log.info("Quota is now "+quota);
		
		hostNum++;
		log.info("Traffic at"+traffic)
		traffic++;
		
    }
	
	private boolean trafficPassage(){
		//update the traffic based on the current time and the last time it updated the traffic
		if(lastTimeDecremented!=null){
			int dec = (int)(Math.round((System.currentTimeMillis()-lastTimeDecremented))/1000)
			log.info("Traffic reduced by: "+dec);
			if(dec>0){
				traffic-=dec
				lastTimeDecremented=System.currentTimeMillis()
				if(traffic<0)
					traffic=0;
			}
		}else{
			lastTimeDecremented=System.currentTimeMillis()
		}
		//check if the traffic is passing
		log.info("Traffic at " + traffic)
		return traffic<$trafficLimit;
	}
}



